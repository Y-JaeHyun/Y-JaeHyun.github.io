---
layout:     post
author:     bcnote3314
title: 	go 언어 - 4
subtitle: ㄱㄱㄱ
category: Note
---

# 데이터 타입
 
* 숫자
  * uint8 ~ 64, int8 ~ 64 : 각 크기에 따른 정수값
  * uint, int : OS에따라 32 / 64 자동
  * uintptr : uint와 동일한 크기이며 포인터를 저장할때 사용
  * float32/float64 : 부동소수점, 32는 7자리 64는 15자리 정밀도 보장
  * complex64/128 : 복소수, 각각 float32/float64의 크기의 실수부와 허수부를 가지고있음
  * byte : uint8과 동일한 크기이며 Byte 단위 저장
  * rune : int32와 크기 동일, 유니코드 저장
  * 특이사항
    * Go언어는 묵시적 형변환을 허용하지 않기 때문에 타입이 일치하지 않은경우 명시적 형변환을 통해 변경 후 진행해야 컴파일 에러가 발생하지 않는다.  
    * 큰 데이터 형에서 작은 데이터 형으로 변환시 넘치는 비트의 경우 버리게 된다. (32->16으로 변환시 뒤에서 16개 비트만 사용하여 변환)
    * Go언어에서는 오버플로우, 언더플로우 상황을 허용하지 않으며 컴파일 에러를 발생시킨다. (언더플로우도 오버플로우 에러로 출력된다)
    * 변수 크기를 사용하기 위해 Sizeof 함수를 사용해야 하는데 unsafe 패키지를 사용하며 바이트 단위로 계산된다.  

* 문자열
  * string
  * 특이사항
    * " " (쌍따옴표)를 사용한 값을 저장한다.
  * 문자대신 \u, \U 를통해 유니코드로 문자를 표현할수 있다.
  * \x를 통해 바이트값을 저장할 수 있다.
  * ` `를 통해 여러 라인의 문자열을 저장할 수 있다.
  * 문자열 길이를 구하는 len 함수는 기본 명령이다. 
  * 문자 길이는 UTF-8 기준으로 출력된다.
  * 한글, 한자등의 문자열의 실제 크기를 위해 unicode/utf8 패키지의 RuneCountInString 함수를 통해 구할 수 있다.
  * 문자열의 배열형태의 원소 접근이 가능하다.
  * 다른 문자열을 대입하는 것은 가능하지만 문자열의 배열 원소 접근을 통한 일부 수정은 불가능하다.

* 그 외
  * bool (1byte)
  * 상수
    * const 상수명 자료형 = 초기값
      * 변수와 동일한 형태로 사용가능하며 자만 값의 변경이 불가능하고, 초기값이 반드시 필요하다.
  * 열거형 
  
```go
const (
	APPLE = 1
	ORANGE = 2
	BANANA = 3
)

const (
	APPLE = itoa //  0부터 시작이며 + [숫자] 를 통해 시작 index를 조정할수 있다.
	ORANGE
	BANANA
)

연산을 통해 index를 조정할 수도 있다. 
const (
	APPLE = 1 << itoa // 1
	ORANGE = 1 << itoa // 2
	BANANA = 1 << itoa // 4
)
```