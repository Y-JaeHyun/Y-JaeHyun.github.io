---
layout:     post
author:     bcnote3314
title: 도커 & 쿠버네티스 배경
category: Note
tags: 		Docker&k8s
---

# 도커 & 쿠버네티스 탄생 배경

## 도커 탄생 배경

서버 관리, 상당히 많은 의미를 내포하고 있지만 어쨋든 서버가 안정적으로 구동되도록 유지하기 위한 노력들을 말한다.  
IT 회사 입장에서 이 서버 관리를 못해서 문제가 생기는 것은 단순히 단기 수익 측면이 아니라 장기적으로 큰 문제들을 유발할 수 있다.  
그렇기 때문에 많은 회사, 단체에서 이런 서버관리를 '잘' 하기 위한 노력, 연구들이 계속해서 되어왔다.  

일예로 Ansible과 같은 도구들은 서버 관리를 편리 하게 위해 나온 도구들이다.  
관리자가 직접 bash 명령을 입력하는 것이 아니라 정해진 규칙대로 수행이 가능하다.  

다만 다수의 복잡한 서버들을 관리하다보면 그러한 도구들을 활용하는것 역시 어려워 진다.  
Ansible에서 수행하는 스크립트들도 도구의 사용 방법자체도 복잡해질 것이다.  (물론 수동으로 하는것 보다야 좋겠지만)  
하나의 서버에서 다수의 서비스들이 유기적 동작해야하고 그에대한 버전관리등 복잡해지기 위한 조건은 얼마든지 많다.  

가상머신을 사용한다면 어떨까?  
서비스들을 각각 별도로 구동시켜주기 때문에 서비스 자체의 관리측면에서는 편해질 수는 있다.  
다만 가장큰 단점은 일단 속도가 느리다.  
또한 가상머신 특정 벤더에 의존성이 생기는 경향이 있다.  그렇기 때문에 클라우드 환경에 적합하지는 않다.

그래서 나온것이 도커.  
실행환경을 컨테이너로 관리하며 OS와 상관없이 어디서든 동작할수 있고 효율적이다.  

컨테이너의 특징
* 가상머신과 비교해서 컨테이너 생성이 쉽고 효율적이다.
* 컨테이너 이미지를 이용한 배포/롤백이 간단하다.
* 개발, 테스트, 운영환경을 모두 동일한 환경으로 구축하기 쉽다.
* 특정 벤더에 종속적이지 않은 오픈소스이다.  

도커를 사용하게 되면 기본적으로 모든 서비스들을 컨테이너 단위로 관리하게 된다.  
websever / DB / CI / ... 등등 다양한 서비스들이 각 컨테이너에서 동작한다.  

기본적으로 아래의 프로세스로 정형화된 개발 단계를 거치게 된다.
```
Developer -> Build -> Ship -> Run 
```

서버 관리자 입장에서는 Docker 이미지만 잘 만들어져 있으면 크게 관여할것이 없어 보일수 있다.  
하지만 하나의 서버에서 점점더 많은 컨테이너가 구동되면서 수십, 수백, 수천개의 컨테이너에 대해 관리를 해줘야 하는 상황이 온다.  
즉 Run 이후에 또다른 어떤 프로세스가 필요하게 된 상황이다.  

# 도커 컨테이너 관리 문제점

도커 서버가 10대 있을때 개발된 이미지를 배포하기 위해서는 어떻게 해야할까?
10대 서버에 각각 접속해서 기존버전을 Stop 하고 최신 버전을 Run 해주는 동작을 수행해야 한다.  
만약 해당 버전에 문제가 생긴다면 다시 기존버전으로 롤백을 수행해야 하는데, 그것또한 다시 모든 서버에 접속해서 수동으로 처리해 주어야 한다.  

만약 특정 컨테이너에 부하가 생긴다면 어떤 조치가 필요할까?
동일한 역할을 하는 컨테이너가 하나더 생성이 될것이고 서비스 부하를 막기 위해 컨테이너 앞단에 로드밸런서가 추가되어야 한다.  
최근에 마이크로 서비스 아키텍쳐가 유행하면서 이러한 작은 서비들이 많아지고 각 서비스간에 통신이 많아지면서 컨테이너간의 복잡한 연결관계를 가지게 된다.  
그러한 상황에서 컨테이너가 추가 될때마다 관리자가 해줘야 하는 작업은 점점더 복잡해질 것이다.  

외부에서 내부 컨테이너에 접근하기 위해선 어떤 작업이 필요할까?
컨테이너와 외부를 연결해주는 프록시 서버가 필요하다.  
다만 매번 서비스가 추가될때마다 프록시에 설정도 수동으로 해주어야 한다.  

서비스 장애, 부하 모니터링 작업은 어떻게 해야할까?
자동화된 모니터링 시스템을 개발하지 않는이상 수동으로 각 서버에 저장된 로그를 보고 분석해야 한다.  

# 컨테이너 오케스트레이션

복잡한 컨테이너 환경을 효과적으로 관리하기 위한 도구를 의미한다.  
서버 관리자가 하는 일들을 대신하기 위한 프로그램을 의미할 수 있다.  

컨테이너 오케스트레이션의 특징

* 클러스터 
클러스터란 다수의 서버노드를 묶은 개념이다.  (추상화)
다수의 서버를 하나하나 관리하기는 어렵기 때문에 클러스터라는 단위로 묶어서 관리하며 이를 중앙 제어하기 위한 마스터 서버가 존재한다.
관리자는 마스터서버에 특정명령어를 보내면 마스터서버는 하위 클러스터에 전달하며 각 클러스터의 노드끼리는 각각 통신이 되어야한다.  
* 상태관리
관리자가 원하는 상태값을 입력하면 컨테이너 오케스트레이션에서는 그 상태를 유지하기 위한 노력을 한다.  
만약 특정 Application 컨테이너를 3개로 유지하는 상태값을 지정한 경우에 1개의 컨테이너에 문제가 발생하면 오케스트레이션에 의하여 문제가 발생한 노드가 내려가고 새로운 노드가 생성되어 3개를 유지하게 된다.  
* 배포관리
다수의 서버와 서비스 구동환경에서 새로운 서비스가 온전히 추가되기 위해서는 가장 여유가 있는 서버 노드를 찾고 해당 서버에 배포를 해주어야 한다.  
관리자가 직접 서버들에 붙어서 상태를 확인하지 않아도 오케스트레이션에 의하여 알아서 해당 서버를 찾고 배포까지 수행해준다.  
* 버전 관리
특정 서비스에 대한 버전 관리를 지원한다.  배포 및 롤백이 편하게 수행할 수 있다.  
* 서비스 등록 및 조회
새로운 서비스가 구동되면 해당 서버의 IP에 대해 프록시 서버와 매핑 및 서비스 재시작 등을 자동으로 수행해준다.  
* 볼륨 관리
각 노드별 볼륨(스토리지) 관리를 설정으로 처리할수 있도록 지원해준다.

# 오케스트레이션 도구

컨테이너 오케스트레이션은 개념적인 것이기 때문에 이를 실제로 구현한 도구들은 다수 있다.  
도커 진영에서도 이를 위해 도커 스웜이란 도구를 만들었었고, 그외에 쿠버네티스, 노마드 등 다양한 도구들이 나왔다.  

다만 현재는 쿠버네티스가 주도적으로 이끌어 가고 있는 추세로 보인다.

# Kubernetes

구글에서 만든 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼이다.  
구글의 경우 1주일에 20억개의 컨테이너를 생성했기 때문에 이러한 배포시스템이 필수적으로 필요했었다.  

현재는 Cloud Native라고하는 오픈소스 단체로 소스가 이관되었다.  

쿠버네티스는 거대한 스케일, 유연성, 어디서든 동작할수 있다고 강조해서 소개하고 있다.  

왜 Kubernetes를 해야 할까?

* 오픈 소스 : github에 이미 공개되어있다.  
* 참여 기업 : 해외로 보면 Google, Intel, MS등, 국내로보면 Naver, Kakao등 이미 국내외 대다수의 기업들이 사용하고 있다.  
* 무한한 확장성 : 쿠버네티스를 바탕으로 돌아가는 다양한 플랫폼들이 이미 다수 존재한다.  
* 사실상의 표준 : 도커에서도 도커 스웜이 있음에도 불구하고 쿠버네티스를 지원하며, 다수의 클라우드 업체에서도 매니지 서비스로 지원을 한다.  


