---
layout:     post
title:      마스터링 이더리움 - 6
author:     bcnote3314
tags: 		blockchain Ethereum MasteringEthereum
subtitle:  블록체인 정복기	
category: Block
---

# 마스터링 이더리움 - 챕터 7(2)

마스터링 이더리움 챕터 7 내용 요약. 

## 데이터 타입

- bool
- 정수(int, uint) : 기본은 256비트이며 8비트에서 256비트까지 뒤에 숫자를 붙여서 선언하면 된다.
- 고정소수점(fixed, ufixed) : (u)fixedMxN 으로 선언하며 M은 비트단위 크기(8~256) N은 소수점 이하 자리수(최대18)를 의미한다.
- 주소(address) : 20 바이트 이더리움 주소이며, address객체에는 balance, transfer 등과 같이 유용한 함수가 내장되어있다.
- 바이트 배열(고정) : 고정 크기의 바이트 벼일이며 bytes1에서 bytes32까지 선언된다.
- 바이트 배열(가변) : bytes 또는 string으로 선언된 가변 크기의 바이트 배열
- 열거형 : enum
- 배열 
- 구조체
- 매핑 : 키 => 값 쌍에 대한 해시 조회 테이블. ex. mapping(KEY=>VALUE) NAME
- 시간 단위 : seconds minutes, hours, days를 기본단위인 seconds의 배수로 변환하여 사용할 수 있다.
- 이더 단위 : wei, finney, szabo, ether를 기본단위인 wei의 배수로 변환하여 사용할 수 있다.

## 사전 정의된 글로벌 변수 및 함수

### 트랜잭션/메세지 콜 컨텍스트

msg객체는 컨트랙트 실행을 시작한 트랙잭션 호출 또는 메시지 호출 이며 많은 속성들이 포함되어있다.

- msg.sender : 컨트랙트를 호출한 주소를 나타낸다. 다만 항상 EOA인 것은 아니며 특정 컨트랙트가 다른 컨트랙트를 호출한 경우는 컨트랙트 주소가 될 수도 있다.
- msg.value : 전송된 이더의 값(wei)
- msg.gas : 남은 가스의 양이며 솔리디티 v0.4.21에서 gasleft 함수로 대체됨.
- msg.data : 데이터 페이로드가 컨트랙트에 포함된다.
- msg.sig : 함수 선택자인 데이터 페이로드의 처음 4바이트.

### 트랜잭션 컨텍스트

tx 객체는 트랜잭션 관련 정보에 접근하는 방법을 제공한다.

- tx.gasprice : 트랜잭션을 호출하는데 필요한 가스 가격
- tx.origin : 이 트랜잭션에 대한 EOA의 주소 (안전하지 않다.)

### 블록 컨텍스트

block 객체에는 현재 블록에 대한 정보가 포함되어 있다.

- block.blockhash(blockNumber) : 지정된 블록의 해시. 솔리디티 v0.4.22에서 blockhash 함수로 대체됨.
- block.coinbase : 현재 블록 수수료 및 보상의 수취인 주소
- block.difficulty : 현재 블록의 난이도(pow)
- block.gaslimit : 현재 블록에 포함된 모든 트랜잭션에 소요될 수 있는 최대 가스양
- block.number : 현재 블록 번호(블록체인 높이)
- block.timestamp : 채굴자가 현재 블록에 넣은 타임 스탬프

### address 객체

입력으로 전달되거나 컨트랙트 객체에서 형변환되는 모든 주소에서 사용가능한 속성과 메소드

- address.balance 주소의 잔액. 단위는 wei이다.
- address.transfer(amount) : wei 단위의 금액을 이 주소로 전송시킨다. 오류가 발생할 경우 예외가 발생한다. 
- address.send(amount) : transfer와 마찬가지이지만 예외 상황에서 예외 발생 대신에 false를 리턴한다. (항상 반환값 확인이 필요하다.)
- address.call(payload) : 저수준 Call 함수. 오류가 발생하면 false 반환. (안전하지 않다.)

### 내장 함수

- addmod, mulmod : moduler 더하기 및 곱하기. ex) addmod(x,y,z) = (x+y)%z
- keccak256, sha256, sha3, ripemd160 : 다양한 표준 해시 함수
- erecover : 서명에서 메세지 서명에 사용된 주소를 복구한다.
- selfdestrunct(recipient_address) : 현재 컨트랙트를 삭제하고 계정의 나머지 이더를 받는사람 주소로 보낸다.
- this : 현재 실행중인 컨트랙트 계정의 주소.

## Contract 정의

솔리디티의 주요 데이터타입은 contract 이다.  
객체지향 언어에서 사용하는 객체와 마찬가지로 컨트랙트는 데이터와 함수를 포함한 컨테이너 개념이다.  

컨트랙트와 유사한 형태로 interface와 library 객체 유형을 제공한다. 

- interface : 인터페이서는 함수가 정의되어있지 않고 선어만 되어있다는 것을 제외하면 컨트랙트와 완전히 동일한 구조이다. 즉 실제 구현은 상속받은 자식에 의하여 정의된다.
- library : 라이브러리 컨트랙트는 delegatecall 메서드를 사용하여 한번만 배포되고 다른 컨트랙트에서 사용되기 위한 컨트랙트이다.

## 함수

컨트랙트 내에서 EOA 트랜잭션이나 또다른 컨트랙트에 의해 호출될 수 있는 함수.  
기본 구문은 아래와 같다.  
> function FunctionName([parameters]) {public|private|internal|external} [pure||constant|view|payable][modifiers] [returns (return type)]

- FunctionName : 트랜잭션이나 컨트랙트등에서 호출될때 사용되는 함수 이름. 각 컨트랙트마다 한개씩 이름없이 정의될수 있는 함수가 있다. 폴백 함수라고 하며 인수가 없으며 아무것도 반환하지 못하는 함수이다.
- parameters : 매개 변수

함수의 가시성(visibility)과 관련된 예약어
- public : 모든 곳에서 호출가능하며 기본값이다.
- external : 외부함수는 명시적으로 키워드 this가 붙지 않는 한 컨트랙트내에서는 호출될 수 없다. 그외에는 public과 동일하다.
- internal : 내부함수는 컨트랙트 내에서만 접근할 수 있으며 다른 트랜잭션이나 컨트랙트에서 호출될수 없다. 이 컨트랙트를 상속받은 컨트랙트에 의해서는 호출할 수 있다.
- private : 내부함수와 비슷하지만 상속 컨트랙트에서도 호출할 수 없다.

함수의 동작과 관련된 예약어
- constant, view : view 는 함수가 컨트랙트의 상태를 변경하지 않은경우 사용한다. (constant는 view랑 동일하지만 이제 사용하지 않는 예약어이다.)
- pure :  스토리지에서 변수를 읽거나 쓰지 않는 함수다. 저장된 데이터를 참고하지 않으며 순수하게 전달받은 인자에 대해서만 처리하고 데이터를 반환한다.
- payable : payable함수는 입금을 받을수 있는 함수이다. 선언이 없다면 입금이 거부된다. 

## 생성자 / selfdestrunct

생성자는 컨트랙트가 생성될때 딱 한번 수행한다.  
생성자는 일반 객체지향 언어처럼 컨트랙트와 동일한 이름의 함수를 만드는것으로 사용가능하다.  

```solidity
    contract test {
    	function test() {
    		// 생성자
    	}
    }
```

하지만 만약 오타가 나거나 컨트랙트의 이름이 변경될때 생성자 이름이 같이 변경되지 않는등으로 뭔가 문제가 생긴다면 모든 코드내용이 공개된 블록체인에서는 상당히 위험한 문제를 유발할 수 있다.  
예를들어 생성자에서 컨트랙트의 소유자를 정해주는 작업을 하도록하였는데 이름에 오타가 난경우 해당 함수는 생성자가 아니기 때문에 여러번 호출 될수 있으며 타인에 의해 소유권을 강탈당하는 문제가 생길수 있다.

이러한 잠재적인 문재점들을 막기 위하여 이름 없이 construct 키워드를 .

```solidity
    contract test {
    	constructor() {
    		// 생성자
    	}
    }
```
	
selfdestrunct는 컨트랙트를 소멸을 위한 내장 함수이며 만약 특정 컨트랙트를 삭제 가능하게 만들고 싶다면 명시적으로 추가해주어야한다.  
기본으로 제공되지 않기 때문에 일반적인 컨트랙트는 영구적으로 지속이 되는 것이다.  
> selfdestruct(address recipient);

## 변경자

함수 변경자라는 특별한 유형의 함수가 있다.

function이라는 키워드 대신 modifier라는 키워드를 사용하며 컨트랙트 내에서 함수에 적용되어야할 여러 조건을 생성하기 위해 사용된다.
즉 함수 접근 제어를 하기 위한 것이다.  

```solidity
    modifier onlyOwner {
    	require(meg.sender == owner);
    	_;
    }
```
	
require 는 조건이을 확인하는 예약어이며 _; 구문을 통하여 실제 modifier된 함수의 이후 내용이 실행되는 방식이다.  
하나의 함수의 다수의 변경자를 포함하는 것도 가능하다.

변경자는 함수의 전제 조건을 작성하고 일관되게 적용할수 있기 때문에 코드를 읽기 쉽고 보안 감사에 용이하다.  
접근 제어 외에도 다양한 목적으로 사용 가능하다.

## 상속

상속은 일반적인 객체지향에서 말하는 상속과 동일하며 솔리디티는 다중상속 또한 지원한다.
상속을 위해서는 아래와 같은 문법으로 사용 가능하다.

```solidity
    contract child is parent1, parent2 {
    	...
    }
```
	
코드의 재사용과 모듈화를 통하여 간결한 코드를 만드는 것이 주 목적이다.

## 예외처리

솔리디티에서는 예외처리를 위하여 3가지 함수를 사용한다.

assert와 require는 조건을 평가하고 조건이 거짓이라면 에러로 실행을 중지시키는 방식으로 동작한다.
통상적으로 assert는 결과가 참으로 예상되는 곳에서 사용하며 내적인 조건들이 만족되는지 테스트 해보는 의미이다.

이에 비해 require는 입력값이 설정 조건의 개다값에 맞는지 테스트 할 때 사용한다.
요구조건이 만족되지 않ㅇ는 경우 에러를 발생시켜 나머지 부분이 실행되는 것을 막는다.

solidity 0.4.22버전에서 require에 에러 메세지를 추가하는 것도 가능하게 되었다.

```solidity
    require(msg.sender == owner, "only the contract owner can call this function!");
```
	
revert는 컨트랙트의 실행을 중지하고 모든 상태 변경을 되돌린다.  

이러한 예외처리들은 가스 소비량을 증가시키게 되지만 에러 상황에서 다양한 리포트를 제공받을수 있기 때문에 과하지도 모자라지도 않게 적절한 규형을 맞춰 작성해야 한다.

## 이벤트

트랜잭션이 완료되면 트랜잭션 영수증을 발행한다.  
이와같이 특정 이벤트가 발생했을때 해당 행위에 대한 로그나 감시를 통하여 사용자 인터페이스에 반영하고나 상태변화등을 반영하기 위해 이벤트 객체를 지원한다.

이벤트는 parameter를 가지고 있으며 이들은 시리얼라이즈 되어서 블록체인 트랜잭션 로그에 기록이 된다.
인수 앞에 indexed라는 키워드를 붙여서 애플리케이션에서 검색하거나 필터링 할 수 있는 인덱싱된 테이블의 값으로 만들 수 있다.

또한 트랜잭션 로그에 이벤트 데이터를 집어넣기 위해 emit라는 키워드를 사용한다.

```solidity
    contract test {
	    event Withdrawal (address indexed to, uint amount);
	    [...]
	
	    function withdraw(uint withdraw_amount) public {
		    [...]
		    msg.sender.transfer(withdraw_amount);
		    emit Withdrawal(msg.sender, withdraw_amount);
	    }
    }
```

이 이벤트를 받기 위해서는 web3.js 라이브러리를 사용해서 사용자 인터페이스상에 변화를 줄수 있으며 truffle 프레임워크를 통해서 동작 확인도 가능하다. (해당부분은 실습 필요)

## 다른 컨트랙트 호출 

- 새로운 인스턴스 생성될때

다른 컨트랙트를 호출하기 위한 가장 안전한 방법은 직접 다른 컨트랙트를 만드는 것이다.  
그렇게 하면 인터페이스와 동작이 확실하다.  

일반적인 객체지향 언어와 마찬가지로 new 키워드를 통하여 인스턴스를 생성할수 있다.
물론 해당 컨트랙트의 소스 코드가 import되어서 관련 내용을 알수 있게 해주어야 한다.

```solidity
    import "Test.sol"
    
    contract Test2 {
    	Test _test;
    	
    	constructor() {
    		_test = new TEST();
    	}
    }
```

- 존재하는 인스턴스의 주소 부여하기

이미 블록체인 상에서 동작하는 인스턴스의 주소값을 가져와서 실행하는 방법이다.  
다만 실제 동일한 객체인지 여부를 확실히 알수 없기 때문에 위험할 수 있다.

```solidity

    import "Test.sol"
    
    contract Test2 {
    	Test _test;
    	
    	constructor(address _t) {
    		_test = TEST(_t);
    	}
    }
```
	
- 원시 call, delegatecall
다른 컨트랙트를 호출하기 위한 '저수준' 함수.  
유연하지만 위험한 형태의 메커니즘이다.  

call이라는 함수 매개변수로 호출할 함수 이름과 매개변수를 전달받는 숨은(blind) 호출 방식이며 재진입성등의 문제가 있다. (이후에 따로 다룰 내용)  
call은 함수 호출후 문제가 생겼을 경우 false를 리턴하기 때문에 해당 리턴에 대한 예외처리를 항상 해주어야 한다.

delegatecall은 msg 컨텍스트를 변경시키지 않는 다는 점을 제외하고는 call과 동일하다. 
call은 msg 정보를 실제 호출한 컨트랙트 정보로 변경하지만 delegatecall을 사용하면 유지된 상태로 전달된다.

## 가스 고려사항

이후에도 한번더 다룰 내용이긴 하지만 가스는 스마트 컨트랙트 프로그래밍에서 매우 중요한 고려 사항이다.  
이더리움 트랜잭션이 사용하도록 허락할 최대 계산량을 제한하는 자원이기 때문에 한계를 초과하면 아래의 이벤트가 발생한다.

- 가스 부족 예외 발생
- 실행전의 컨트랙트 상태로 복원
- 가스로 사용된 이더는 수수료로 간주되며 환불되지 않음.

가스는 트랜잭션을 시작한 사용자가 지급하기 때문에 사용자는 가스 비용이 높은 함수를 호출하지 않는것이 좋으며 이를 위해 개발자들은 최소한의 가스비용을 사용하도록 개발해야한다.

이를 위하여 몇몇 지침들이 있다.

1. 동적 크기 배열 피하기

동적 크기의 배열을 통한 반복문은 많은 가스 사용을 초래할수 있다.  
컨트랙트가 원하는 결과를 찾기전까지 혹은 모든 요소에 적용하기 전까지 가스가 소진되며 이더를 낭비하게 된다.  

2. 다른 컨트랙트 호출 피하기

다른 컨트랙트를 호출하는 것은 그 컨트랙트의 가스 비용이 공개되지 않은 상황에서는 어떤 위험이 있을지 모른다.  
검증이 된 라이브러리를 사용해야한다.

3. 가스비용 추정

대부분의 함수는 가스를 측정할수 있으며 estimateGas를 통하여 상당히 정확한 예상치를 제공받을 수 있다.
이는 개발 플로우의 일부로 추가하여 주기적인 평가가 필요하다.

