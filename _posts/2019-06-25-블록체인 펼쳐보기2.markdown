---
layout:     post
title:      블록체인 펼쳐보기 - 2
author:     bcnote3314
tags: 		blockchain 블록체인펼쳐보기
subtitle:  블록체인 정복기	
category: Block
---

# 블록체인 펼쳐보기 - Chapter 03

블록체인 펼쳐보기 챕터 3에 대한 내용 정리

## 블록(block)

**블록**이란 블록체인의 가장 기본적인 요소.

이전장에서 해시캐시에 대한 내용을 다룰 때 헤더의 내용들과 랜덤 및 카운터들을 포함한 내용을 포함한 해시의 결과값을 가지고  작업 증명을 한다고 했다.

![이메일 블록](http://drive.google.com/uc?export=view&id=1lEoqY3yTXRapqjV79jky270pAMmlSmmu)

이때 위 그림과 같이 헤더의 내용들과 랜덤값, 카운터를 통틀어 블록이라고 볼수있다.
즉 이 블록에 대하여 해시값의 결과가 앞의 20비트가 0을 만족하는 카운터 값을 찾아내는 것이 작업 증명이다.

SHA의 총 비트수가 160 비트이기 때문에 수식으로 표현하면 **SHA(블록) < 2^160^** 로 표현할수 있다.
이때 앞에 20비트가 0인값을 찾는 것이기 때문에 실제 카운트는 **SHA(블록) < 2^140^** 을 만족하는 카운트 값을 찾는 노력을 해야한다. (앞의 값은 모두 0으로 고정되어야 하기 때문에 160-20승)

이와 같은 형태는 블록 체인에서도 동일하게 사용된다. 안의 데이터만 다를 뿐이다.

![블록](http://drive.google.com/uc?export=view&id=1xUEljSTO3gyiTI3NgUd4pgt7cYVgJ09S)

블록을 만드는 사람은 내용과 상관없이 전체 블록에 대하여 앞의 20비트가 0을 만족하는 **Nonce**를 찾는것이 목표이다. 
만약 블록중에 앞에 20비트가 0이 아닌 블록이 있다면 이것은 가짜! 라고 판단할수 있다.

### SHA 256

블록체인에서는 화폐의 기능때문에 이전 해시캐시에서 사용했던 SHA-160보다 더 강화된 SHA-256을 사용한다.
또한 앞자리 20비트가 아닌 40비트를 0으로 만족하는 값을 찾는 조건으로 강화되었으며 사실상 2^20^만큼 난이도가 어려워지게 되었다.

## 블록의 연결(block, chain)

블록은 어느 분야에서 사용하느냐에 따라 무수한 데이터들이 들어갈 수 있다.
이런 데이터들이 계속해서 늘어난다면 하나의 블록에 모든 정보를 담는것은 불가능하다. (Nonce를 찾기 위해서는 이미 내용이 고정되어야 있어야 하며, 이후에 제공되는 정보가 같은 블록에 추가될수 없다)

블록체인에서는 이 문제를 블록을 연결하는 방법으로 해결했다.

![블록체인](http://drive.google.com/uc?export=view&id=1RjmmjlPOuBuvl4VRwOezaVUA3R6U2ULk)

블록 0의 해시 결과를 블록 1에 내용에 추가하고 블록 1에 해시 결과를 블록 2에 추가하는 형태로 연결해 두는 것이다.
이것이 의미가 있는 것은 블록 0이 있어야 블록 1을 만들 수 있고 블록 0의 내용과 그 해시 결과에 따라 블록 1의 Nonce값이 달라지게 되어 검증의 결과가 달라지게 된다.
물론 블록 1을 만드는 시점에도 블록 0의 검증(SHA 결과가 앞부분 20자리가 0인지)을 수행한 뒤 신뢰가 되었을때 진행하기 때문에 블록 1이 블록 0을 지지하고 검증해주는 역할을 하게 되는 것이며 이것이 100개 1000개의 블록이 쌓인다면 그만큼의 신뢰성이 보장된다는 의미가 된다.
만약 블록 0의 내용을 부정하고 원하는 내용으로 대체하고 싶다면 그 100개 1000개의 신뢰를 깰만큼의 지지를 받아야 한다. (해시값을 계산하기 위한 전산 능력이 전체 채굴 노드의 50%이상이 되어야 한다. 다만 신뢰가 없는 것을 지지해서 얻는 이득이 없기 때문에 불가능한 일이라고 본다.)

## 블록헤더(blockheader)

블록에는 실제 거래장부라고하는 수많은 데이터들이 존재한다.
그것을 모두 처리하기 위하여 체인의 형태를 쓰도록 했지만 그래도 거래장부의 내용을 모두 블록으로 관리할 필요성은 없다. 데이터가 많으면 난스를 찾기 위한 계산량이 많아지기 때문에 적합하지 않은 구조이다.

실제 이메일 예제에서도 본문내용을 모두 블록에 포함하지 않았다. 헤더 즉 실제 필요한 데이터 외에 추가적인 정보들을 관리하는 정보를 따로 처리하는 방법을 사용한다.
이때 헤더와 블록의 실제 내용을 연결하기 위하여 블록내용을 요약한 정보를 헤더에 포함해줄 수 있다. (이것도 헤더와 블록간의 체인이라고 볼수 있을것 같다.)

![블록헤더](http://drive.google.com/uc?export=view&id=1HjPCEOz3oUcoQ-qwBJ16DMRDJmgKbzKH)

요약을 하기 위해서는 당연히 해시를 이용한다. 변경되지 않은 데이터임을 보장하는 블록의 실제 내용(페이로드)의 해시값을 헤더에 포함하는 것으로 실제 내용도 위조되지 않았음을 보장받을수 있다. 

> 오픈소스들을 보면 md5값과 같이 압축파일등의 해시값을 표시해주는 경우가 많은데 해당 오픈소스가 실제 원본임을 보장하는것과 같은 이치이다.

다만 실제로는 해시값을 더 효과적으로 사용하기 위하여 **머클루트**값을 사용하지만 이것은 책에선 설명이 없기때문에 추후 정리해보는 걸로... (머클루트는 머클트리라는 이진트리 구조의 루트값이며 본문 거래 내용을 조회하기 편하다는데..)
