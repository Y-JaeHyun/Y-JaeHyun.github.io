---
layout:     post
author:     bcnote3314
title: 	go 언어 - 9
subtitle: ㄱㄱㄱ
category: Note
tags: 		go
---

# 고루틴

고루틴은 함수를 동시에 실행 시켜주는 것으로, 스레드와 비교해서 훨씬 간단하고 운영체제의 리소스를 적게 사용하기 때문에 많은 수의 고루틴을 만들 수 있다.  

사용방법은 함수 호출시 앞에 go 예약어를 붙이면 끝이다.  
고루틴은 함수의 return이나 rutime.Goexit 함수를 통해 종료되지만 리턴값에 대한 처리를 할 수는 없다.  

Go언어는 기본적으로 CPU Core를 하나만 사용하도록 설정되어있다.  
멀티코어를 사용하기 위해서는 설정이 필요하다.  

```go

package main

import (
        "fmt"
        "runtime"
)


func main() {
        runtime.GOMAXPROCS(runtime.NumCPU())

        fmt.Println(runtime.NumCPU())
        fmt.Println(runtime.GOMAXPROCS(0))

        for i:=0; i < 100; i++ {
                go func(n int) {
                        fmt.Println(n, "Hello")
                }(i)
        }

}


```

위 예제와 같이 함수 내부에 클로저를 정의한뒤에도 고루틴을 사용할 수 있다.  
이때 특이한점은 반복문안에서 고루틴을 사용하는경우의 동작이다.  

일반적으로 반복문안에서 클로저를 사용하게 되면 당연히 반복 과정에서 순차 실행하게 된다.  
(여기서 순차실행이란 실행순서를 보장한다는 의미는 아니다. 반복 과정에서 함수 호출을 한다는 의미일뿐이다.)

하지만 고루틴으로 클로저를 사용하게 되면 반복문이 먼저 다 돈이후 고루틴을 실행하게 되기 떄문에 반복되는 index를 클로저 안에서 사용해야 한다면 반드시 매개변수를 통해 값을 복사하는 형태로 전달해야 한다.

# 채널

채널은 고루틴끼리 데이터를 주고받으며 실행 흐름을 제어하기 위한 기능이다.  
모든 타입을 채널로 사용할 수 있으며, 채널 자체는 레퍼런스 타입이다.  

채널은 make를 사용해서 메모리 공간을 할당해서 사용한다.  

* make(chan 자료형)


```go
package main

import "fmt"

func sum(a int, b int, channel chan int) {
        channel <- a + b
}


func main () {
        channel := make(chan int)

        go sum (1, 2, channel)

        n := <-channel

        fmt.Println(n)
}

```

다른건 특별할건 없다.  
'<-' 키워드를 통해서 go루틴 내에서 채널에 전달한 정보를 외부에서 전달 받을 수 있다. (변수의 위치에 따라 채널에 넣는것과 빼는것이 결정된다.)


<- 키워드를 사용하면 채널을 통해서 값이 전달받을 때까지 대기하게 된다.  
즉 고루틴이 채널에 값을 넣기까지 기다리는 것으로 동기화의  역할도 수행하는 것이다.  

채널 생성시 make 함수에서 매개변수로 채널의 자료형만 지정한 경우 동기 채널이 생성된다.  
동기 채널의 경우 값을 보낸 쪽도 반대편에서 값을 꺼낼때까지 대기하는 것을 말한다.  

반대로 값을 받는 쪽도 마찬가지로 값을 줄때까지 대기하게 된다.  

