---
layout:     post
author:     bcnote3314
title:  성능을 올리기 위한 삽질 기록
subtitle: Cache Memory
category: Note
tags: 		OS Experiences
---

# 개요

제품의 성능을 위한 고민을 하던중 VTune 이라는 인텔의 성능 분석 도구를 이용하여 부하 지점을 분석해본 적이 있었다.  
상용제품이기도 하고 회사 업무 과정을 다 적을순 없지만 상당히 많은 정보를 제공해준다.  

그곳에서 발견한 부하 원인중의 하나가 Cache Miss 빈도 였다.  
가장 Cache Miss가 발생하는 부분이 전역변수에 카운팅을 하는 부분이였다.

회사 제품의 기존 구조 특성(이라는 변명?)상 전역변수의 사용이 많았다.  
그동안의 제품군의 성능까지는 큰 문제로 다가오지는 않았다.
H/W(CPU, NIC 등..) 성능자체가 워낙 좋기 때문이기도 하고 Memory 자체도 속도가 제법 빠른 영역이라고 생각했을 수도 있다.  

하지만 차세대 제품군에서 지원해야하는 성능 수치를 만족할수는 없었다.  
그때부터 하나씩 기존 구조에서 문제가 되는 부분들을 찾아보기 시작했고 그런 과정중에 배운것들을 조금씩 정리해보려고 한다.  

근데 사실 보면 대학교 다니면서 배웠던 것들이 많다... (그때당시 별생각없이 외우고 시험봤던 것들이 남아있더라면 더 이해가 쉬웠을수도..)


# Cache Memory

## Cache Memory 특성 

캐시메모리의 특성은 작고 빠르다는 것이다.  
컴퓨터에 들어가는 메모리 특성을 가진 부품을 크게 나누면 3가지가 있다.  
CPU(의 Cache Memory), RAM, HDD
앞에 있을수록 속도에 가중을 주며, 뒤로갈수록 용량에 가중을 주었다는 차이가 있다.  

용량이 작은 메모리를 잘 활용하는 특성이 지역성(Locality)이다. 
지역성은 크게 시간적 지역성과, 공간적 지역성 두 가지로 나뉜다.  
시간적 지역성은 최근에 액세스된 주소가 가까운 미래에 다시 엑세스 될 가능성이 높다는 개념이며,  
공간적 지역성은 액세스된 주소와 인접한 주소가 액세스 될 가능성이 높다는 개념이다.

캐시메모리에 Write 동작이 발생한다면?
Write Policy에 의하여 동작의 차이가 발생한다.  
Write Through : 캐시의 변화를 바로 Main Memory에도 Write 해준다. 일관성 측면에서 장점이나 상대적으로 속도가 느린 메모리의 IO 처리를 대기해야 하기 때문에 성능이 떨어진다. 
Write Back : 변경사항을 캐시에만 기록하고 실제 해당 블록이 해제될때 Main Memory 한번에 Write한다. 상대적으로 IO 빈도가 낮기 때문에 성능이 좋지만 캐시와 메모리간의 값이 일치하지 않는다.

이외에도 Replacement Algorithms등 알아두면 좋은 개념이 많다. (나중에 개념정리..)

## 메인 메모리 구조

기본적으로 유저 메모리는 4개의 영역으로 나뉜다.  
(흔히 OS나 메모리관련 설명에서 자주보는 그림이다.)

![메모리 영역](http://drive.google.com/uc?export=view&id=1VNTpcdxWqW_TynaqVtgdqiJ6-XIUJ_dv) 

Text : 코드영역이라고도 하며 유저가 작성한 코드 즉 실행한 코드가 저장되는 공간이다. 
Data(+BSS) : 전역 변수, 정적 변수가 할당되는 공간이다.
Heap : C로 치면 malloc과 같이 프로그램 실행중에 동적으로 사용되는 공간이다.
Stack : 환경변수, 지역변수, 파라미터등의 정보를 담고 있다.

여기서 Cache를 활용하기 위해 고심해봐야 할 것은 Data영역과 Heap 영역이다.  
캐시메모리의 지역성이라는 특징을 잘 활용하기 위해서 Data영역과 Heap 영역을 과도하게 사용하는 것은 지양해야 할것이다.


## 왜 Data랑 Heap일까?

Data와 Heap를 잘못 사용하면 Cache Miss의 빈도를 높이게 된다.  
Cache Miss가 발생하려면 캐시에 애초에 데이터가 없거나, 없어진 경우일 것이다.

첫번째로 애초에 데이터가 없던 경우이다.  

대부분의 프로그램은 작성된 코드를 순차적으로 실행한다.  
즉 동작하는 함수에서 접근하는 데이터도 순차적으로 접근을 하게 될텐데, 지역변수로 선언된 변수들의 접근은 모두 공간적 지역성 특성에 의해 캐시에 데이터가 존재할 확률이 높다.  
하지만 전역변수나, 동적할당 받은 변수의 경우에는 최초 접근시에 항상 캐시에 존재할 수 없는 데이터 이며 캐시 사용성 측면에서 좋지않다.  

두번째로 데이터가 없어진 경우이다.  

지금의 CPU는 당연하게도 멀티코어의 환경이며 성능을 올리기 위해 점점 더 코어의 갯수가 늘어나고 있다.  
아래는 그림은 CPU의 구조도이다.

![CPU](http://drive.google.com/uc?export=view&id=1_vp0LnP1dXKffM7k60uKUxWbzQKjLZX9) 

L1, L2 캐시는 CPU의 각 코어내부에 존재하며 L3는 공유한다.
L1, L2의 캐시들의 HIT율이 높을수록 당연히 성능 향상의 도움을 준다.  
하지만 자기들끼리 데이터 경쟁을 하면서 서간의 견제로 인하여 전혀 이득을 보지 못하는 경우가 있다.  

캐시에서 데이터가 없어지는 경우가 어떤것이 있을지 생각해본다.  
먼저 사용빈도가 낮아 자연스럽게 LRU형태로 제거되는 케이스가 있을수 있다. 시간적 지역성 특성에 의해 당연히 발생하는 부분이다.  
또 하나는 외압(?)에 의하여 강제로 제거되는 케이스이다.  

위에서 이야기 한바와같이 WriteBack Policy를 사용하는 경우 캐시에서 해당 영역이 제거되기 전까지는 메모리에 Write동작을 하지 않는다.  
이때 만약 1번 캐시가 특정 메모리 영역의 값을 갱신하고 있는 상황에 2번 캐시도 해당 메모리 영역의 값을 갱신 하려고 한다.  
하지만 지금까지 1번이 값을 갱신해둔 값은 현재 메모리에는 갱신되어있지 않다.  
이때 2번은 1번의 캐시를 강제로 제거 시키면서 메모리에 값을 쓰게 한다.

만약 그 두개의 코어가 계속해서 같은 영역을 접근한다고 하면????
두 코어가 경쟁하듯 계속해서 양쪽의 캐시를 제거하게 되며 성능 향상의 효과를 전혀 볼수 없게 된다.  

간단한 예제로 보면 아래와 같은 케이스이다.  

```c
int TEST[2] = {0, };

// 첫번쨰 스레드에서 동작, 1번 코어 할당
int thread0() {
	while(1) {
		TEST[0]++;
	}
}

// 두번쨰 스레드에서 동작, 2번 코어 할당
int thread1() {
	while(1) {
		TEST[1]++;
	}
}

```

어라? 같은 영역이라면서 각 스레드는 배열0번, 배열1번 다른 공간에 씁니다?!  
이것도 역시 공간적 지역성 특징에 의한 것으로 캐시에 정보를 갱신할때는 접근 변수 뿐아니라 근처에 있는 변수들을 묶어서 갱신하게 된다.  
즉 1번 코어와 2번코어는 같은 메모리 '영역'에 값을 쓰기 때문에 캐시의 효과를 전혀 얻을수 없게 된다.

## 해결 방법?

여기 적는 방법 외에 다양한 방법들이 있을 수 있다.  

가장 간단한 방법으로는 전역변수를 로컬변수로 변경하는 것이다.  
위 예제는 전역변수의 특정 공간에 각 스레드에서 값을 갱신하고 있다.  
반대로 로컬 변수의 특정 영역에 값을 갱신하고 전역변수에는 지역변수의 주소값만을 가지고 있게 하는 것으로 충분하다.  
write 동작이 일어나는 부분은 각각의 thread 이고 참조하는 변수는 각 스레드의 지역 변수이기 때문에 다른 스레드 간섭에 의한 Cache Miss 발생의 빈도를 크게 줄일 수 있다.  

```C
int *TEST[2];

// 첫번쨰 스레드에서 동작, 1번 코어 할당
int thread0() {
	int test = 0;
	test[0] = &test;
	while(1) {
		test++;
	}
}

// 두번쨰 스레드에서 동작, 2번 코어 할당
int thread1() {
	int test = 0;
	test[1] = &test;
	while(1) {
		test++;
	}
}

```

TLS(Thread Local Storage) 변수를 사용하는 방법도 전역변수에 의한 문제를 푸는데 도움이 될 수 있다.   
TLS 변수는 C언어 기준으로 전역변수의 자료형 앞에 __thread 키워드를 붙이는 것으로 선언이 가능하다.  

TLS 변수는 정적, 전역 변수를 각각의 스레드에 독립적으로 만들어 준다.  
분명 하나의 변수 명을 사용하지만 각각의 스레드에 독립적으로 존재하는 변수로 처리된다.  
(컴파일러에 의하여 처리되는 것으로 보았으나 자세한 동작 형태는 공부가 더 필요하다.)


# 마무리

우선 나의 경우에는 첫번째로 제시한 지역변수로 변경한뒤 해당 주소값만 전역변수에 매핑해두는 형태로 이 문제를 해결했다.  

위와 같은 코드는 특정 값을 카운팅 하여 통계 정보를 남기거나 로깅을 위한 용도로 많이 사용되었다.  
최초 해당 코드 개발자의 의도는 명확해 보인다.  
다수의 스레드에서 동일한 변수에 카운팅을 하면 Lock이 필요하기 때문에 thread의 갯수만큼 배열을 만들어서 카운팅을 한뒤 필요할때 해당 값을 참조를 했다.  
VTune 등의 분석 도구를 이용하여 확인 하지 않았다면 별다른 특이점을 찾지 못했을것 같다.  

무분별한 전역변수의 사용을 지양하고 캐시의 활용 범위를 늘리기 위한 고민이 필요하다.

