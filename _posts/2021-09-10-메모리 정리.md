---
layout:     post
author:     bcnote3314
title:  성능을 올리기 위한 삽질 기록
subtitle: Cache Memory
category: Experiences
---

# Cache Memory 활용

## Cache Memory 특성 

캐시메모리의 특성은 작고 빠르다는 것이다.  
컴퓨터에 들어가는 메모리 특성을 가진 부품을 크게 나누면 3가지가 있다.  
CPU(의 Cache Memory), RAM, HDD
앞에 있을수록 속도에 가중을 주며, 뒤로갈수록 용량에 가중을 주었다는 차이가 있다.  

용량이 작은 메모리를 잘 활용하는 특성이 지역성(Locality)이다. 
지역성은 크게 시간적 지역성과, 공간적 지역성 두 가지로 나뉜다.  
시간적 지역성은 최근에 액세스된 주소가 가까운 미래에 다시 엑세스 될 가능성이 높다는 개념이며,  
공간적 지역성은 액세스된 주소와 인접한 주소가 액세스 될 가능성이 높다는 개념이다.

캐시메모리에 Write 동작이 발생한다면?
Write Policy에 의하여 동작의 차이가 발생한다.  
Write Through : 캐시의 변화를 바로 Main Memory에도 Write 해준다. 일관성 측면에서 장점이나 상대적으로 속도가 느린 메모리의 IO 처리를 대기해야 하기 때문에 성능이 떨어진다. 
Write Back : 변경사항을 캐시에만 기록하고 실제 해당 블록이 해제될때 Main Memory 한번에 Write한다. 상대적으로 IO 빈도가 낮기 때문에 성능이 좋지만 캐시와 메모리간의 값이 일치하지 않는다.

이외에도 Replacement Algorithms등 알아두면 좋은 개념이 많다. (나중에 개념정리..)

## 메인 메모리 구조

기본적으로 유저 메모리는 4개의 영역으로 나뉜다.  
(흔히 OS나 메모리관련 설명에서 자주보는 그림이다.)

![메모리 영역](http://drive.google.com/uc?export=view&id=1VNTpcdxWqW_TynaqVtgdqiJ6-XIUJ_dv) 

Text : 코드영역이라고도 하며 유저가 작성한 코드 즉 실행한 코드가 저장되는 공간이다. 
Data(+BSS) : 전역 변수, 정적 변수가 할당되는 공간이다.
Heap : C로 치면 malloc과 같이 프로그램 실행중에 동적으로 사용되는 공간이다.
Stack : 환경변수, 지역변수, 파라미터등의 정보를 담고 있다.

여기서 Cache를 활용하기 위해 고심해봐야 할 것은 Data영역과 Heap 영역이다.  
캐시메모리의 지역성이라는 특징을 잘 활용하기 위해서 Data영역과 Heap 영역을 과도하게 사용하는 것은 지양해야 할것이다.


## 왜 Data랑 Heap일까?

Data와 Heap를 잘못 사용하면 Cache Miss의 빈도를 높이게 된다.  
Cache Miss가 발생하려면 캐시에 애초에 데이터가 없거나, 없어진 경우일 것이다.

첫번째로 애초에 데이터가 없던 경우이다.  

대부분의 프로그램은 작성된 코드를 순차적으로 실행한다.  
즉 동작하는 함수에서 접근하는 데이터도 순차적으로 접근을 하게 될텐데, 지역변수로 선언된 변수들의 접근은 모두 공간적 지역성 특성에 의해 캐시에 데이터가 존재할 확률이 높다.  
하지만 전역변수나, 동적할당 받은 변수의 경우에는 최초 접근시에 항상 캐시에 존재할 수 없는 데이터 이며 캐시 사용성 측면에서 좋지않다.  

두번째로 데이터가 없어진 경우이다.  

지금의 CPU는 당연하게도 멀티코어의 환경이며 성능을 올리기 위해 점점 더 코어의 갯수가 늘어나고 있다.  
아래는 그림은 CPU의 구조도이다.
![CPU](http://drive.google.com/uc?export=view&id=1_vp0LnP1dXKffM7k60uKUxWbzQKjLZX9) 

L1, L2 캐시는 CPU의 각 코어내부에 존재하며 L3는 공유한다.
L1, L2의 캐시들의 HIT율이 높을수록 당연히 성능 향상의 도움을 준다.  
하지만 자기들끼리 데이터 경쟁을 하면서 서간의 견제로 인하여 전혀 이득을 보지 못하는 경우가 있다.  

캐시에서 데이터가 없어지는 경우가 어떤것이 있을지 생각해본다.  
먼저 사용빈도가 낮아 자연스럽게 LRU형태로 제거되는 케이스가 있을수 있다. 시간적 지역성 특성에 의해 당연히 발생하는 부분이다.  
또 하나는 외압(?)에 의하여 강제로 제거되는 케이스이다.  

위에서 이야기 한바와같이 WriteBack Policy를 사용하는 경우 캐시에서 해당 영역이 제거되기 전까지는 메모리에 Write동작을 하지 않는다.  
이때 만약 1번 캐시가 특정 메모리 영역의 값을 갱신하고 있는 상황에 2번 캐시도 해당 메모리 영역의 값을 갱신 하려고 한다.  
하지만 지금까지 1번이 값을 갱신해둔 값은 현재 메모리에는 갱신되어있지 않다.  
이때 2번은 1번의 캐시를 강제로 제거 시키면서 메모리에 값을 쓰게 한다.

만약 그 두개의 코어가 계속해서 같은 영역을 접근한다고 하면????
두 코어가 경쟁하듯 계속해서 양쪽의 캐시를 제거하게 되며 성능 향상의 효과를 전혀 볼수 없게 된다.  

간단한 예제로 보면 아래와 같은 케이스이다.  

```c
int TEST[2] = {0, };

// 첫번쨰 스레드에서 동작, 1번 코어 할당
int thread0() {
	while(1) {
		TEST[0]++;
	}
}

// 두번쨰 스레드에서 동작, 2번 코어 할당
int thread1() {
	while(1) {
		TEST[1]++;
	}
}

```

어라? 같은 영역이라면서 각 스레드는 배열0번, 배열1번 다른 공간에 씁니다?!  
이것도 역시 공간적 지역성 특징에 의한 것으로 캐시에 정보를 갱신할때는 접근 변수 뿐아니라 근처에 있는 변수들을 묶어서 갱신하게 된다.  
즉 1번 코어와 2번코어는 같은 메모리 '영역'에 값을 쓰기 때문에 캐시의 효과를 전혀 얻을수 없게 된다.

## 해결 방안?

