---
layout:     post
author:     bcnote3314
title: 	Go 언어 - 6
subtitle: 기본 문법 세번째
category: Note
tags: 		go
---

# 배열

Go의 배열은 기몬적으로 크기가 고정되어있고 0부터 시작하는등 성격 자체는 C와 유사하다.  
사용하기 위한 다양한 방식이 있는데 아래의 형태들을 지원한다.  
```go

var a [10]int
var b [10]int = [10]int{1,2,3,4,5,6,7,8,9,10} 
vak c = [10]int{1,2,3,4,5,6,7,8,9,10}
d := [10]int{1,2,3,4,5,6,7,8,9,10
e := {
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10, // 여러 라인으로 분리해서 선언하는경우 반드시 마지막요소에도 콤마가 필요하다
}
f := [...]int{1,2,3} // 초기화 시점에 ... 로 크기를 셋팅하면 알아서 크기에 맞춰준다.
g := [3][3]int{  //2차원 배열
	{1,2,3},
	{4,5,6},
	{7,8,9},
}
```


C와 차이점이 있다면 Go 언어의 배열 변수는 배열 전체를 뜻하는 것으로 첫번쨰 요소의 포인터값이 아니다.  
즉 요소를 복사하기 위해서는 arr2 := arr1의 형태로 대입을 하면 배열의 전체 요소가 복사가 된다.  

# 슬라이스

슬라이스는 배열과 동일한 성질을 가지고 있지만 길이가 고정되어있지 않으며 동적으로 크기가 늘어난다.  
슬라이스의 선언은 배열의 크기를 지정하지 않는 방식으로 가능하다.  
다만 실제 슬라이스를 사용하기 위해서는 make 함수를 통해 공간을 할당해야 한다.


```go

var a[]int // 슬라이스 선언, 크기는 0
var b[]int = make([]int, 10) // int형 10개짜리 슬라이스 할당
var c = make([]int, 10)
d := make([]int, 10) 
e := []int{1,2,3,4,5}
f := []int{
	1,
	2,
	3,
	4,
	5,
}
```


슬라이스에는 길이외에도 용량이라는 요소가 존재한다.  
위에 사용한 바와같이 용량을 따로 지정하지 않으면 길이와 동일한 값으로 자동 설정된다.  
길이는 현재 인덱스로 접근 가능할 수 있는 공간이다.  만약 길이 이상의 인덱스에 접근한다면 런타임 에러가 발생한다.
또한 값을 추가하거나 삭제함에 따라 길이가 변경될 수 있다. "len(슬라이스명)" 을 통해 길이를 알 수 있다.  
  
용량은 실제 메모리상에 할당된 공간이다. 슬라이스는 배열의 길이가 동적으로 변경되기 때문에 길이와 용량을 구분한다.  
슬라이스내에 요소를 추가하다가 용량이 가득 찬 경우에도 자동으로 용량이 늘어나게 된다.  

```go
package main

import "fmt"

func main () {
    slice := []int{1,2,3,4,5}
    fmt.Println(len(slice), cap(slice))
    fmt.Println(slice)

    slice = append(slice,6)
    fmt.Println(len(slice), cap(slice))
    fmt.Println(slice)
}

$ go run slice.go
5 5
[1 2 3 4 5]
6 12
[1 2 3 4 5 6]

```

append 함수는 슬라이스에 데이터를 추가하거나 슬라이스끼리의 합치는 것을 도와준다.  
슬라이스를 합치고 싶은 경우에는 slice1 = append(slice1, slice2...) 의 형태로 합칠수 있다.  
"..."은 모든 요소들의 집하바을 표현하는 문구이기 때문에 반드시 입력되어야 한다.  


슬라이스는 레퍼런스 타입이다.  
내장된 배열에 대한 포인터를 나타낸다.  
즉 슬라이스를 대입하면 값이 복사되지 않고 참조되는 형태이다. (C에서의 배열 이름이라고 보면 될거같다.)

즉 배열 arr2 = arr1 은 모든 값을 복사하였기 때문에 이후 arr1의 요소를 갱신하더라도 arr2에 영향을 주지 않았지만  
slice2 = slice1 의경우 주소값을 가지고 있기 때문에 arr1의 요소를 갱신하는 경우 같이 변하게 된다.  

만약 모든 슬라이스를 복사하고 싶은 경우 copy 함수를 사용할 수 있다.  
copy(slice2, slice1) 명령을 통해 1의 요소를 2로 모두 복사할 수 있다.  
다만 이때 slice2의 길이가 slice1보다 작다면 앞에서 부터 순차대로 복사하다가 길이가 부족한 부분 부터는 복사하지 않는다.  

또한 슬라이스의 특정 위치를 지정하여 부분슬라이스를 만들 수 있다.
Python 과 같은 언어에서 배열의 특정 범위부분만 접근할 때와 비슷한 형태이다.  

슬라이스[시작인덱스:끝인덱스+1]

부분 슬라이스 역시도 복사가 아니라 레퍼런스 이기 때문에 내용을 바꾸면 기존 슬라이스의 내용도 바뀌게 된다.  
배열에도 동일한 형태로 사용 가능하며 역시 레퍼런스 이기 때문에 배열 요소가 변경되는건 동일하다.  

# 맵

Go에서는 기본 자료형으로 맵을 지원한다.  
Python의 딕셔너리와 비슷한 개념이다.  
사용방법은 아래와 같다.  

var 맵이름 map[키자료형]데이터자료형

맵은 슬라이스와 마찬가지로 레퍼런스 타입이며, make 함수를 통하여 공간을 할당해야 값을 넣을수 있게된다.  

```go
var a map[string]int = make(map[string]int)
var b = make(map[string]int)
c := make(map[string]int)

d := map[string]int{"apple":1000, "banana":2000}
e := map[string]int{
	"apple":1000,
	"banana":2000,
}
```

만약 맵에서 존재하지 않는 키값을 조회햇을 때는 빈값(숫자 형태의 자료형이면 0, 문자열이라면 "")이 출력된다.  
값이 존재하는지 확인하기 위한 방법은 두번쨰 인자를 활용하는 것이다.  
아래와 같은 조건 형태가 자주 사용되기 때문에 알아둘 필요가 있다.  

```go

if price, exist := fruit["banana"]; exist {
	fmt.Println(price)
```

맵 내부의 모든 데이터를 출력하는 것은 range 키워드를 통해 사용 가능하다.  

```go

for key, value := range fruit {
	fmt.Println(key, value)
}

```

삭제는 delete 함수와 key값을 통해 가능하다.


```go

a := map[string]int{"apple":1000, "banana":2000}
delete(a, "apple")

```

맵 내부에 맵을 만드는 방법도 가능하다.  
맵도 어쨋든 자료형이기 때문에 데이터 자료형에 다시 map을 사용하는 것이다.

```go
fruit := map[string]map[string]int{
		"apple": map[string]int {
			"count" : 1
			"print" : 1000
		},
		"banana": map[string]int {
			"count" : 10
			"print" : 2000
		},
}

fmt.Println(fruit["apple"]["price"])

```