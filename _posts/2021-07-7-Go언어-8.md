---
layout:     post
author:     bcnote3314
title: 	go 언어 - 8
subtitle: ㄱㄱㄱ
category: Note
tags: 		go
---

h3. 포인터

Go 언어는 C/C++과 같이 포인터를 지원한다.  

* var ptr *int

Go언어는 NULL을 nil 로 포현한다.  
또한 포인터를 선언하면 기본적으로 nil로 초기화 된다.  

비어있는 포인터 변수는 바로 사용할 수 없고 new함수를 통해 메모리를 할당해야한다.  
new 함수는 자료형에 맞춰 메모리 공간을 할당하며 GO에서는 가비지 컬렉션을 지원하기 떄문에 메모리를 할당한 뒤 해제하지 않아도 된다.  

또한 C와 동일하게 일반 변수에 & 키워드를 붙이면 주소값을 받아서 포인터 변수에 대입할 수 있다. 

```go
var ptr *int = new(int)
var temp int = 2
*ptr = 1

fmt.Println(*ptr) // 1

ptr = &temp

fmt.Println(*ptr) // 2

```

다만 Go에서는 C와달리 포인터 변수에 계산을 통해 메모리 위치를 변경하거나 메모리 주소값을 직접 입력하는 형태로 사용이 불가능하다.  
또한 C에서와 동일하게 매개변수에 포인터를 사용하는 것으로 call by address를 지원한다.  

# 구조체

C의 구조체와 차이점이랄게 크게 없다.  
다만 구조체도 포인터 형으로 선언할수 있는데 C와 다르게 포인터형 구조체 접근할때 -> 를 사용하지 않고 동일하게 . 을사용한다.  
또한 포인터 변수 값을 출력하면 &{멤버변수값1, 멤버변수값2, ..., 멤버변수값n} 의 형태로 앞에 &가 붙어서 출력된다.

```go

type People struct{
	name string
	age int
	weight int
}

type People struct{
	name string
	age, weight int
}

var people1 People

var peoptr *People = new(People)

var people2 People = People{"김철수", 20, 70}
var people3 := {"김철수", 20, 70}


peoptr.name = "김철수"
peoptr.age = 20
peoptr.weight = 70

fmt.Println(peoptr)    // {"김철수", 20, 70}
fmt.Println(people2)   // &{"김철수", 20, 70}

```

구조체 포인터를 사용하면 메모리 할당과 동시에 초기화할 방법은 없다.  
하지만 다른언어의 생성자와 비슷한 형태로 구현은 가능하다.  

```go
type People struct{
	name string
	age, weight int
}

func NewPeople(name string, age int, height int) *People {
	return &People(string, age, height)
}

func main () {
	peoptr := NewPeople("김철수", 20, 70) // People 주소값을 리턴받아 포인터 변수에 대입한다.
	
	fmt.Println(peoptr) // &{"김철수", 20, 70}
	
}


```

위와 같은 방식이 가능한 이유는 Go에서는 지역변수를 계속 참조하고 있다면 스코프를 벗어나도 변수가 해제되지 않기 떄문이다. (이미 이전에 클로저 써봤을떄 비슷한걸 경험했었을거다.)




